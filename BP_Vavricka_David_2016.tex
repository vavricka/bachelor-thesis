\documentclass[thesis=B,czech]{FITthesis}[2012/06/26]

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{dirtree}
\usepackage{float}
\usepackage{color}
\usepackage{listings}

\lstdefinelanguage{RainerScript}
{
  morekeywords={
    module, if, then, while, for, load, set, unset,
	template, name, type, string, action, stop, and,
    from, to, var, stringtobedeleted, severity
  },
  sensitive=false,
  morecomment=[l]{\#},
  morecomment=[s]{/*}{*/},
  morestring=[b]"
}

\lstdefinelanguage{PKGBuild}
{
  morekeywords={
    pkgname, pkgver, arch, depends, source, md5sums,
    build, package
  },
  sensitive=false,
  morecomment=[l]{\#},
  morecomment=[s]{/*}{*/},
  morestring=[b]"
}

\lstdefinelanguage{Ash}
{
  morekeywords={
    if, fi, then, else, exit, return, echo, time, rm, awk, grep,
    cat, tr, cut, for, in, do, done
  },
  sensitive=false,
  morecomment=[l]{\#},
  morecomment=[s]{/*}{*/},
  morestring=[b]"
}

\lstdefinestyle{AshStyle} %{language=Bash,style=numbers,style=MyFrame,frame=none,backgroundcolor={}}
{language=Ash,                % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)}          % if you want to add a comment within your code
}

\lstdefinestyle{RainerScriptSimpleStyle} %{language=Bash,style=numbers,style=MyFrame,frame=none,backgroundcolor={}}
{language=RainerScript,                % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=lines,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)}          % if you want to add a comment within your code
}

\lstdefinestyle{RainerScriptStyle} %{language=Bash,style=numbers,style=MyFrame,frame=none,backgroundcolor={}}
{language=RainerScript,                % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)}          % if you want to add a comment within your code
}

\lstdefinestyle{PKGBuildStyle} %{language=Bash,style=numbers,style=MyFrame,frame=none,backgroundcolor={}}
{language=PKGBuild,                % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)}          % if you want to add a comment within your code
}

\department{Katedra softwarového inženýrství}
\title{Flexibilní logování pro embedded Linuxové systémy}
\authorGN{David}
\authorFN{Vavřička}
\authorWithDegrees{David Vavřička}
\supervisor{Ing. Matěj Laitl}
\acknowledgements{Doplňte, máte-li komu a za co děkovat. V~opačném případě úplně odstraňte tento příkaz.}
\abstractCS{Cílem této bakalářské práce je analýza, návrh a následná implementace nového logovacího řešení pro set-top box EKT DID7006mTF. Hlavními požadavky jsou snížení vytížení sítě a umožnění vzdálené změny konfigurace logování servisním technikům.

Na základě analýzy bylo vybráno open-source řešení Rsyslog a byly pro něj naprogramovány dva moduly a napsány podpůrné skripty.

Závěrem bylo řešení otestováno na reálném hardware, bylo demonstrováno splnění požadavků a příznivé provozní vlastnosti."}
\abstractEN{This Bachelor’s thesis is focused on analysis, design and implementation of a new logging solution for EKT DID7006mTF set-top box. Main requirements are reduction of network load and to allow relevant personnel to change logging configuration remotely.

On the basis of the analysis was chosen open-source solution Rsyslog and were developed two Rsyslog modules and some subsidiary scripts.

The solution was tested on real hardware where was demonstrated accomplishment of all required goals and good running characteriscs.}
\placeForDeclarationOfAuthenticity{V~Praze}
\declarationOfAuthenticityOption{4} %volba Prohlášení (číslo 1-6)
\keywordsCS{logování zpráv, logovací démoni, Rsyslog, set-top boxy, vestavěné systémy, Linux}
\keywordsEN{message logging, logging daemons, Rsyslog, set-top boxes, embedded systems, Linux}

\begin{document}

\begin{introduction}
Zadavatelem práce je společnost vyvíjející set-top boxy pro sledování internetové televize, která prodává hotová řešení pro IPTV streaming jednotlivým provozovatelům.

V současné době využívají služeb provozovatelů desetitisíce zákazíků a trend ukazuje, že se jejich počet bude do budoucna nadále zvyšovat.

Každý ze set-top boxů v domácnostech uživatelů odesíla stovky zpráv za minutu o svém stavu na servery jednotlivých provozovatelů. Jejich zpracování představuje pro servery velkou zátěž, dále zprávy mohou zahltit už tak vytíženou linku ve směru od uživatele a proto byl sepsán seznam technických požadavků, jež si kladou za cíl umožnit snížit objem logů posílaných na servery.

Tato práce se ve své první části zabývá analýzou technických požadavků a výběrem vhodného postupu řešení.
 
Na základě analýzy je posléze provedena implementace, ve které je kladen důraz na použití pouze volně šířitelných open-source projektů a jejich případné rozšíření.
 
V závěru práce je výsledné řešení podrobeno testovaní, kde se kromě splnění technických požadavků zkoumají z důvodu omezeného výkonu set-top boxů nároky na výpočetní výkon.
\end{introduction}

\chapter{Technické požadavky}
Cílem je upravit logovací řešení pro set-top box EKT DID7006mTF~\cite{ekt7006} tak, aby splňovalo technické požadavky popsané v této kapitole. Řešení musí fungovat a být otestováno na zmíněném modelu set-top boxu a pokud možno by mělo být přenositelné i na jiné typy set-top boxů.

Původním záměrem bylo rozdělit požadavky na základní a rozšířené. Nakonec zadavatel rozhodl, že všechny níže zmíněné požadavky jsou základní a tedy jejich implementace je nutná pro splnění práce.

\section*{Snížení objemu logů}
Je žádoucí umožnit snížit objem zasílaných logů z důvodu přílišného zatížení sítě a serverových disků. A to tak, že zadavatel bude schopen nadefinovat pro každou komponentu úroveň severity zpráv, od které mají být posílány na server. Výchozí nastavení dodá zadavetel.

\section*{Vzdálená konfigurace}
Technické řešení musí být schopno za běhu pomocí SHELL-ového API měnit maximální severitu zpráv pro jednotlivé komponenty a dále toto API musí umožnit nastavit výchozí severitu, která se použije pro komponenty ji nemají explicitně nastavenou. Takto změněné nastavení musí být perzistentní i po restartu STB. Výchozí nastavení se obnoví až po factory resetu. API navrhne dle své libovůle sám řešitel.

\section*{Rate-limiting odesílaných zpráv}
Nové logovací řešení musí být schopné provádět rate-limiting odesílanych zpráv tak, aby nepřekročilo maximální vyhrazenou šířku pásma. Naivní rate-limiting je i v existujícím řešení, řešitel navrhne výchozí nastavení nového řešení tak, aby přibližně odpovídalo současnému chování. 

\section*{Formát logů}
Je nutno zachovat formát logů jako ho má původní řešení, aby se jednalo o drop-in replacement bez nutnosti jakkoli měnit konfiguraci serveru, který sbírá logy od set-top boxů.

\section*{Razítkování zpráv}
Každé zprávě se musí přidat textový prefix id=N, kde N monotonicky roste s každou zprávou.  To slouží pro detekci ztracených zpráv. Id přeteče po dvaceti bitech. Po rebootu STB id znovu začíná od 1.

\section*{Post-processing zpráv}
Zadavatel má pouze částečnou kontrolu nad zprávami generovanými aplikacemi na set-top boxu, například nedokáže ve všech případech eliminovat dlouhé prefixy u zpráv. Je proto nutno takové prefixy rozpoznat a vhodně odfiltrovat před odesláním. Ze stejného důvodu mají některé zprávy nevhodně vyplněnou severitu a položku app-name. Jejich správné hodnoty jsou uloženy v textu zprávy, jejíž formát je pro jednotlivé skupiny zpráv konstantní. Řešení bude schopné tyto údaje z těla zprávy extrahovat a nahradit jimi původní metadata. Tato pravidlo musí být možné definovat a měnit bez nutnosti nového sestavení softwaru. 
Řešitel vytvoří pro ukázku 3 pravidla, která budou sloužit zadavateli jako šablony pro možná budoucí filtrovací pravidla.

\chapter{Logování v linuxových systémech}
Systémoví administrátoři se musí umět vypořádat s množstvím nejrůznějších zpráv ze systémových komponent nebo například ze vzdálených systémů.
Pro jejich snažší správu slouží na UNIX-ových a tedy i LINUX-ových systémech tzv. Syslog.
Tím je myšlen Syslog formát zpráv, který zprávám dává unifikovanou podobu.
Dále je tím myšlen Syslog protokol, tedy specifikace pro přenos Syslog zpráv po síti.

\section{Syslog démon}
Démon je v UNIXovém světě označení pro takový proces, který oproti běžným procesům neintereaguje přímo s uživatelem, ale běží na pozadí operačního systému a funguje samostatně. Hlavním účelem syslog démona je sběr logů od ostatních procesů, které následně v závislosti na jeho konfiguraci dokáže filtrovat a ukládat na disk či odesílat na vzdálený server.

\section{Syslog protokol}
Syslog protokol~\cite{NetworkAdmSurGuide} spatřil světlo světa již v roce 1980. Má ho na svědomí Eric Allman, který jej psal s úmyslem využít ho pro potřeby Sendmail projektu. Nicméně postupem času byl tento protokol díky skvělému návrhu a díky své jednoduchosti adaptován i jinými projekty. Rozšířil se na různé OS a později se stal standardem pro logování na většině Unixových systémů.
Tento protokol poskytuje možnost zařízením posílat notifikační zprávy ať už skrze sít a nebo lokálně v rámci jednoho zařízení na syslog server, kterým je již v minulé kapitole zmíňený syslog démon.

\subsection{The BSD syslog Protocol - RFC 3164}
Až po přibližně 20-ti letech od vzniku syslog protokolu sepsal Chris Lonvick dokument RFC3146~\cite{RFC3164} popisující daný protokol. Do té doby existovala velká spousta v detailech se lišících implementací, což mělo za následek v jistých případech nekompatibilitu. Dokument čítá celkem 19 stránek kde je především detailně popsán formát a parametry zpráv.

\subsection{The Syslog Protocol - RFC 5424}
Oficiální standard vznikl až s příchodem Syslog protokolu RFC 5424, který světu představil v roce 2009 jeho autor Rainer Gerhards. Počet stránek se rozrostl na 37 a došlo k některým zásadním a velice užitečným změnám.

Nový standard umožňuje použití libovolného trasnportního protokolu~\cite{RFC5424-TrProt}, oproti RFC 3164, kde je jako transportní protokol pevně určeno UDP~\cite{RFC3164-UDP}.
Mírných změn doznal také formát zpráv, který je možno strukturovaně rozšiřovat dle specifických potřeb~\cite{RFC5424-MsgForm}. To má ovšem za následek jeho zpětnou nekompatibilitu s RFC~3164.

\section{Syslog formát zpráv}
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{images/syslog-message-format}
	\caption[Formát syslog zprávy]{Formát syslog zprávy (dle RFC 3164 i 5424)}
\end{figure}

Syslog zpráva se skládá ze 3 částí jak je pro lepší představu graficky vyobrazeno na obrázku výše.

\subsection{Část PRI}
PRI se skládá z jedno až tří-místného decimálního čísla PRIVAL ohraničeného symboly~\uv{<}~na začátku a~\uv{>}~na konci.
PRIVAL má v sobě zakódované číselné hodnoty parametrů zprávy označovaných jako Severity a Facility.
$$Prival= 8*Facility+Severity$$
Facility určuje zdroj logů a Severity jejich důležitost (tedy zda se jedná například pouze o ladící zprávu nebo naopak o důležitou zprávu například o pádu programu). Na základě těchto dvou hodnot syslog démon provádí základní filtraci zpráv.
Důležitým poznatkem je, že formát PRI je shodný podle dokumentů RFC 5424 i 3164.

\begin{table}[ht]
\centering
	\caption[Tabulka severit podle RFC 3164]{Seznam severit dle RFC 3164.~\cite{RFC3164}}
	\begin{tabular}{|l|l|l|}\hline
		Číselný kód	& Severity & Význam	\tabularnewline \hline \hline
		0		& Emergency	&	Systém je nepoužitelný \tabularnewline \hline
		1		& Alert		&	Vyžadována okamžitá reakce \tabularnewline \hline
		2		& Critical	&	Kritický stav \tabularnewline \hline
		3		& Error		&	Chybový stav	\tabularnewline \hline
		4		& Warning	&	Upozornění na hrozící chybu \tabularnewline \hline
		5		& Notice		&	Neobvyklý stav, ale ne chybový \tabularnewline \hline
		6		& Informational & Informační zpráva \tabularnewline \hline
		7		& Debug		&	Ladící zpráva \tabularnewline \hline
	\end{tabular}
\end{table}

\begin{table}[ht]   %[H] místo [ht] aby to bylo přesně na daném místě
\centering
	\caption[Tabulka facilit podle RFC 3164]{Seznam facilit dle RFC 3164.~\cite{RFC3164}}
	\begin{tabular}{|l|l|l|}\hline
		Číselný kód & Facility & Původ zpráv \tabularnewline \hline \hline
		0		& kern & Zprávy jádra systému	\tabularnewline \hline
		1		& user & Generované uživatelem	\tabularnewline \hline
		2		& mail & Generované emailovým systémem			\tabularnewline \hline
		3		& daemon & Systémoví démoni			\tabularnewline \hline
		4		& auth & Zprávy autorizačního/zabezpečovacího charakteru		\tabularnewline \hline
		5		& syslog & Generované syslogem	\tabularnewline \hline
		6		& lpr & Tiskový systém		\tabularnewline \hline
		7		& news & Network news systém		\tabularnewline \hline
		8		& uucp & UUCP systém			\tabularnewline \hline
		9		& cron & Zprávy plánovacího systému Cron			\tabularnewline \hline
		10		& security & security/authorization messages			\tabularnewline \hline
		11		& ftp & FTP démon				\tabularnewline \hline
		12		& ntp & NTP systém			\tabularnewline \hline
		13		& logaudit & Log audit				\tabularnewline \hline
		14		& logalert & Log alert				\tabularnewline \hline
		15		& clock & Clock démon			\tabularnewline \hline
		16		& local0 & Lokální zprávy (0)			\tabularnewline \hline
		17		& local1 & Lokální zprávy (1)			\tabularnewline \hline
		\ldots	& \ldots				\tabularnewline \hline
		23		& local7 & Lokální zprávy (7)			\tabularnewline \hline
	\end{tabular}
\end{table}

\subsection{Header}
Tato část zprávy obsahuje časovou značku a identifikaci zdroje (podle IP adresy nebo hostname). Přesnou podobu Headeru specifikují dokumenty RFC 3164 a 5424 odlišně. Zatímco starší dokument definuje přesnou podobu časové značky, tak novější specifikace dovoluje různé formáty. Díky tomu není zaručena plná zpětná kompatibilita.

\subsection{MSG}
Část Msg pokrývá zbývající část syslog paketu. Jejím obsahem jsou různé zbývající informace o procesu generujícího danou zprávu a pak samozřejmě samotný text zprávy.

\chapter{Analýza}
Na začátku této kapitoly je popsán STB a na něm běžící pro tuto práci důležité aplikace.
Následuje popis infrastuktury, kde je znázorněna komunikace mezi STB a servery zadavatele.
Kapitolu zakončuje analýza řešení jednotlivých technických požadavků a srovnání logovacích démonů.

\section{Původní řešení}
\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.5]{images/diagram-nasazeni-puvodniho-reseni}
	\caption[Diagram nasazení původního řešení]{Diagram nasazení původního řešení}
\end{figure}

\subsection{HW specifikace STB EKT DID7006}
\begin{description}
\setlength\itemsep{-1ex}
  \item [CPU:] ARM 9 Ali M3733 (1GHz Dual core)
  \item [GPU:] Mali 400
  \item [RAM:] 512MB DDR3
  \item [Perzistentní paměť:] 512MB NAND Flash
\end{description}

\subsection{Runtime prostředí}
Na STB běží OS GNU/Linux s Busybox sadou aplikací, která nahrazuje standardní GNU shellové utility. Busybox aplikace jsou díky své malé velikosti vhodnější pro embedded zařízení. Na druhou stranu neposkytují všechny funkce a možnosti nastavení.

\subsubsection{Browser}
Browser je jednoduchý internetový prohlížeč dodaný výrobcem STB.
V něm běží v Javascriptu zadavatelem napsaná aplikace poskytující uživatelské rozhraní. Mimo to také naslouchá zprávám z aplikačního serveru, na jejichž základě může provádět akce, a to včetně generování POST či GET requestu pro démon dmd.
Tato javascriptová aplikace spolu s dalším podpogramem nesoucím název player generují velké množství logů. Tyto logy nepoužívají standardizovanou syslog množinu severit, ale svou vlastní s ní nekompatibilní. Logovací démon ovšem očekává zprávy právě podle syslog standardu. Implementaci browseru ani playeru nemůže zadavatel měnit a proto je třeba nekompatibilitu vyřešit pomocí logovacího démonu.

\subsubsection{Servisní komponenta dmd}
Dmd je v C++ napsaná servisní komponenta, která zprostředkovává komunikaci mezi Browserem a shellovým prostředím pomocí minimalistického HTTP serveru. Umožňuje JavaScript aplikaci na STB provádět operace, které jsou dostupné jen z shellového API.

\subsubsection{BusyBox Syslogd}
Jedná se o minimalistický logovací démon, který je podrobněji popsán v následující kapitole \uv{Srovnání logovacích démonů}.
Zadavatel mu pro své potřeby navíc doimplementoval číslování jednotlivých zpráv pro rozpoznání výpadku a za druhé naivní rate-limiting zpráv. Ten je naivní z důvodu, že používá statický buffer na počet zpráv, který nebere ohled na jejich velikost a hlavně bufferované zprávy se neodešlou samy, ale jen s nově příchozími zprávami.
Za použití tohoto démonu není možné splnit některé stěžejní technické požadavky, jako například \uv{Snížení objemu logů} nebo \uv{Post processing zpráv}. Proto bude nutné ho nahradit nějakým vyspělejším démonem. Tím se ale zabývá až další kapitola \uv{Nové řešení}.

\subsection{Aplikační server}
Aplikační server se stará o business logiku, například poskytuje uživateli práva přehrát daný kanál nebo film, komunikuje s javascriptovou aplikací, která se vůči němu autorizuje a podobně.
AS není možné v této práci jakkoli měnit. Je nutné zachovat kompatibilitu.

\subsection{Servery pro sběr logů}
Provozovatel vlastní cluster serverů pro sběř logů od desetitisíců STB. Běží na nich Rsyslog nakonfigurovaný pro co nejvyšší propustnost.

\section{Nové řešení}
Prvně je nutno zvážit, zda problém řešit na straně serveru nebo set-top boxu. Vhodnou konfigurací logovacího démona na straně serveru, který by nepotřebné zprávy zavčas rozpoznal, zahodil a dále nezpracovával bychom splnili požadavek na snížení zátěže serverových disků. Přetížení sítě se takto vyřešit ale nedá a proto toto řešení zavrhuji.
Je tedy nutno problém řešit na straně set-top boxu kde původní řešení je postaveno na busy-box syslogd. Nabízí se možnost upravit fungování tím způsobem, aby se logy s nízkou severitou už na set-top boxu zahazovaly a pouze v případě potřeby bylo umožněné na dálku změnit konfiguraci démona tak, aby se povolilo logování pro logy s nastavenou danou komponentou a severitou. To vše přes SHELL-ové API.
Součástí zadání je ale i implementovat rate-limiting zpráv, aby nedocházelo k zahlcení linky. Takovou možnost prostý syslogd neposkytuje a je proto nutno zvážit napsání vlastního démona, nasazení jiného, vyspělejšího logovacího démona nebo rozšíření stávajícího syslog démona.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{images/diagram-nasazeni-noveho-reseni}
	\caption[Diagram nasazení nového řešení]{Diagram nasazení nového řešení}
\end{figure}

\section{Srovnání logovacích démonů}
V této kapitole jsou popsány vybrané logovací démony a v jejím závěru jsou porovnány.
\subsection{BusyBox Syslogd}
Tato logovací utilita se skládá ze dvou démonů, jmenovitě z Klogd, který zachytává logy z kernelu a předává je ke zpracování démonu Syslogd. Syslogd pak zachytává i všechny zbylé zprávy a dále s nimi nakládá. Má však velice omezený rozsah schopností. Dokáže pouze zprávy lokálně ukládat, přeposílat je dále po síti, zahazovat duplikáty, rotovat zprávy v závislosti na velikosti a filtrovat je podle omezených kritérií. Dokáže totiž filtrovat zprávy pouze podle typu facility a už nikoliv podle názvu komponenty, která ji vygenerovala.

\subsection{Syslog-ng}
Syslog-ng je flexibilní logovací démon zaměřený na centralizované a zabezpečené logování. Má široké možnosti nastavení a poskytuje množství funkcí. Takže jeho vhodným nakonfigurováním se dá snadno splnit většina vytyčených technických požadavků~\cite{syslogNg}, až na požadavky na vzdálenou změnu konfigurace a změnu severity zpráv.

\subsection{Rsyslog}
Výčet funkcí Rsyslogu je ještě obsáhlejší než u Syslog-ng~\cite{Rsyslog-features}. Technické požadavky se s jeho použitím tedy také dají splnit všechny, kromě vzdálené změny konfigurace a post-processingu zpráv. Stejně jako Syslog-ng není totiž jen logovacím démonem, ale i analyzérem zpráv. Dokáže tak zprávy podle jejich obsahu měnit, třídit a jinak s nimy nakládat.
Že je Rsyslog vyspělý a kvalitní program dokazuje fakt, že je výchozím logovacím démonem na spoustě linuxových distribucích, jmenovitě například v Ubuntu.
Jeho jedinou slabinu shledávám v nedostatečné dokumentaci.

\subsection{Porovnání logovacích utilit}
Pouhým nasazením jakéhokoli známého logovacího démonu není možné splnit všechny vytyčené technické požadavky. V případě ponechání původního démonu BusyBox Syslogd by pro splnění technických požadavků bylo nutno doimplementovat tolik rozšíření, že by to výrazně přesahovalo rozsah bakalářské práce.

Výhodněji se jeví nasadit pokročilý logovací démon jako je Syslog-ng či Rsyslog. Oba totiž poskytují většinu v této práci požadovaných schopností.
Rsyslog podporuje tzv. modulární systém~\cite{rsysModules}, který poskytuje možnost napsání vlastních modulů (programů), které mohou zásadně rozšiřovat rozsah jeho funkcí a je tak možno jejich použitím doimplementovat chybějící schopnosti. Syslog-ng také poskytuje modulární systém, ale bez podpory modulů třetích stran. Modulární systém Rsyslogu tak představuje hlavní argument, proč byl nakonec vybrán jako nový logovací démon právě Rsyslog.

\chapter{Návrh a realizace}
V úvodu kapitoly je předveden buildovací systém a způsob instalace aplikací pro STB.
Následuje obsáhlý popis Rsyslogu a jeho funkcí včetně ukázek jeho konfigurace.
Dále je popsán vývoj modulů pro Rsyslog a jsou představeny dva vlastní naprogramované.
Kapitolu zakončuje návrh API pro vzdálenou konfiguraci Rsyslogu a popis jeho implementace.

\section{Sestavení a instalace Rsyslogu na STB}
Rsyslog není součástí SDK a tak jej bylo nutné a všechny knihovny na kterých závisí (zlib, libestr, libee, liblogging a libfastjson) zkompilovat a posléze nainstalovat na STB. K tomu bude použit systém Gu.

\subsection{Buildovací systém Gu}
Gu je buildovací systém pro linuxová embedded zařízení, který si klade za cíl zjednodušit a urychlit buildovací proces. Gu využívá balíčkovací systém pacman (převzatý z Arch Linuxu) a nástroj scratchbox2 sloužící k zjednodušení cross-kompilace. Tyto 2 nástroje jsou skryty v konzolovém přikazu \uv{gu}, kterým se celé Gu ovládá.

\subsection{PKGBUILD}
Jedná se o shellový script obsahující informace potřebné pro sestavení jednotlivých aplikací systémem Gu. Jeho syntaxe je podrobně popsána v odstavci níže.

\subsection{Sestavení a instalace aplikací}
Jako příklad zde uvádím soubor PKGBUILD pro sestavení a instalaci Rsyslogu. V podobném duchu jsou napsány i skripty pro ostatní aplikace a knihovny.
\begin{lstlisting}[style=PKGBuildStyle]
pkgname=rsyslog
pkgver=8.16.0-nangu-0.3
arch=('armv7h' 'armv7sp')
depends=('zlib' 'libestr' 'libee' 'liblogging' 'libfastjson')
source=${pkgname}-${pkgver}.tar.gz
md5sums=('SKIP')

build() {
	cd ${pkgname}
	PKG_CONFIG_PATH=/mnt/hdd_1/lib/pkgconfig
	autoreconf -fvi
	./configure --prefix=/mnt/hdd_1 \
	--disable-uuid --enable-mmsequence \
	--enable-mmsevrewrite --enable-mmdelstr
	make V=1
}

package() {
	cd ${pkgname}
	make install DESTDIR=${pkgdir}
}
\end{lstlisting}

\begin{description}
  \setlength\itemsep{-1ex}
  \item [pkgname:] Název balíčku (měl by se shodovat s názvem zdrojového archivu aplikace).
  \item [pkgver:] Verze balíčku (měla by se shodovat s verzí sestavované aplikace).
  \item [arch:] Pole specifikující architektury cílových systémů.
  \item [depends:] Pole názvů balíčků, které musí být nainstalovány před spuštěním tohoto softwaru.
  \item [source:] Seznam souborů nutných pro sestavení balíčku. Soboury mohou odkazovat na lokální úložiště, nebo na vzdálený server, v tom případě se se skript postará o jejich stažení. Komprimované soubory skript automaticky rozbalí.
  \item [md5sum:] Pole kontrolních součtů pro každý specifikovaný \uv{source}.
  \item [build():] Nepovinná funkce obsahující příkazy vedoucí ke konfiguraci a sestavení aplikace.
  \item [package():] Povinná funkce instalující soubory. Funkce je spouštěna až po exekuci ostatních nepovinných funkcí.
  \item [pkgdir:] Proměnná obsahující umístění kořenového adresáře instalované aplikace.
\end{description}

Po vstoupení do adresáře obsahujícím zdrojové kódy aplikace a skript PKGBUILD stačí zadat příkaz \uv{gu build}, čímž se uvede do chodu celý skript. Nejdříve se inicializují proměnné, posléze se vykoná funkce build() a nakonec package(), čímž by měl (pokud nedojde k žádné chybě) vzniknout v umístění \uv{pkdir} balíček s přeloženou aplikací.
Příkazem \uv{gu install <název-vzniklého-balíčku.tar.xz>} nainstalujeme balíček do SDK.

\section{Konfigurace Rsyslogu}
Rsyslog se řídí podle pravidel specifikovaných v konfiguračním souboru /etc/rsyslog.conf. Za použití tzv. compatibility módu~\cite{Rsyslog-comp-mode} podporuje syntaxi známou z dříve na linuxu hojně užívaného démonu sysklogd. Níže je uveden příklad konfiguračního souboru syslog.conf~\cite{Syslog-conf} pro sysklogd. Na levo je možno specifikovat kritéria pro filtraci zpráv podle jejich severity a facility. Na pravo je pak umístění, kam zprávy odesílat.

\begin{lstlisting}[style=RainerScriptStyle]
*.=crit;kern.none            /var/adm/critical
kern.*                       /var/adm/kernel
kern.crit                    @finlandia
kern.crit                    /dev/console
kern.info;kern.!err          /var/adm/kernel-info
\end{lstlisting}

Díky této podpoře je možno velice snadno migrovat z Syslogd na Rsyslogd.
Pro využití i jiných než základních funkcí Rsyslogu je nutno k nakonfigurování pravidel použít syntaxi jazyku Rainerscript, který je z toho důvodu v této práci použit.

\subsection{Rainerscript}
Rainerscript~\cite{RainerScript} je skriptovací jazyk navržený ke správě síťových událostí (převážně nakládání se syslog zprávami) a dále ke konfiguraci softwaru, pro který je používán.
Tento jazyk je totiž teoreticky použitelný v ruzných typech softwarů, nicméně v době psaní této práce byl vyvíjen a reálně pužíván pouze v Rsyslogu.

Jedná se o netypový jazyk, který poskytuje podporu regulárních výrazů~\cite{RainerScriptPropertyReplacer} a má nadefinované užitečné funkce především pro práci s textovými řetězci.
Podrobnosti jsou k nalezení v dokumentu s formální definicí jazyka~\cite{RainerScriptFormalDefinition}.

\subsection{rsyslog.conf}
Níže je uvedena ukázka RainerScript konfiguračního souboru, kde jsou předvedeny základní konstrukce používané při jeho tvorbě. Tato ukázka by měla primárně sloužit zadvateli pro porozumění konfiguračního souboru a jako možný návod na budoucí úpravy.

\begin{lstlisting}[style=RainerScriptSimpleStyle]
module(load="NazevModulu")
\end{lstlisting}
Na začátku souboru je možné načíst různé moduly poskytující doplňující funkce. Příkladem může být modul imklog čtoucí zprávy z kernelu nebo omfwd umoňující posílat zprávy zkrze UDP nebo TCP protokoly. Je nutno poznamenat, že některé moduly nejsou ve výchozím nastavení kompilovány spolu s Rsyslogem a je proto nutno přidat příkazu compile parametr $-$$-$enable$-$<název\_modulu>.

\begin{lstlisting}[style=RainerScriptSimpleStyle]
set $!Promenna="hodnota";
unset $!Promenna;
\end{lstlisting}
Pomocí klíčovích slov set a unset je možné deklarovat a rušit proměnné. Ty začínají znaky \$! a příkaz je nutno ukončit středníkem.

\begin{lstlisting}[style=RainerScriptSimpleStyle]
template(name="nazev-sablony" type="string" string="<%pri%>%TIMESTAMP:::date-rfc3164% %$!macaddr% %syslogtag% id=%$!counter%%msg%\n"
	)
\end{lstlisting}
Šablony definují podobu zpráv. Do proměnné string lze vložit libovolné textové řetězce. Proměnná mezi dvojicí znaků procento je nahrazena jejich obsahem. Použity mohou být vlastní lokální proměnné a nebo tzv. replacement proměnné, vztahující se typicky k syslog zprávě, ve kterých je uložena např. severita nebo například čas odeslání. Nejdůležitější je proměnná msg, kde je uložen text zprávy.

\begin{lstlisting}[style=RainerScriptSimpleStyle]
action(template="nazev-sablony" type="omfwd" Target="192.168.1.10" Port="5514" Protocol="udp" )
\end{lstlisting}

Pomocí akcí se volají jednotlivé moduly. Ty mohou mít různé parametry, které upravují jejich chování. V ukázce výše se volá modul omfwd sloužící k posílání zpráv skrze síť. Parametry specifikují konkrétní IP a port sítě, typ protokolu a název šablony, která upravuje formát zpráv.

\begin{lstlisting}[style=RainerScriptSimpleStyle]
if $programname == 'solid' and $syslogseverity > 5
then {
	#nejaka akce
	stop
}
\end{lstlisting}
	
Použití podmínky if je zřejmé z ukázky výše. V podmínce if se obvykle volají různé akce.

Veškerý text za symbolem \uv{\#} až do konce řádky je považován za komentář.
\\
\\
Nyní po obeznámení se základní syntaxí Rainerscriptu je možno popsat fungování zachytávání jednotlivých zpráv. Ty imaginárně putují skrze kód rsyslog.conf odshora dolů, kde prochází skrze podmínky a akce (které je eventuelně upravují nebo např. zapisují do souborů) a to až do doby, než narazí na klíčové slovo stop nebo na poslední řádek souboru.

\subsubsection*{Rsyslog queues}

\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.4]{images/rsyslog-queues}
	\caption[Rsyslog queues]{Rsyslog queues~\cite{RsyslogQueues}}
\end{figure}

Princip fungování front v Rsyslogu je znázorněn na obrázku níže. Zprávy (ať už lokální nebo ze vzdáleného zdroje putující do Rsyslogu např. skrze UDP) vstupují do Rsyslogu  na obrázku zleva, kde jsou předzpracovány a putují do Main Queue. V dalším kroku jsou zprávy tříděny podle pravidel specifikovaných v rsyslog.conf a putují do jednotlivých action queues. Následně proběhne finální zpracování zpráv a opouštějí Rsyslog skrze výstupní modul ať už zápisem do lokálního souboru nebo např. předáním jinému procesu.

Všechny zprávy tedy projdou nejprve skrze Main Queue a poté skrze libovolný počet Action Queues. Je nutno zmínit, že každá akce obsahuje vlastní frontu, ve které zprávy čekají na zpracování. V případě, že v akci žádnou frontu nepotřebujeme, stačí nastavit jako Action Queue mód Direct mode.

Existují totiž čtyři módy front. Speciálním (a výchozím) je Direct mode. Direct Queues ve skutečnosti nejsou frontami. Neobsahují totiž žádný buffer a zprávy rovnou přeposílají dál. Vhodné jsou například při zápisu logů do souboru na lokální úložiště.

Druhým typem jsou In-Memory Queues, které udržují zprávy v bufferu v operační paměti. Výhodou je vysoká rychlost a nevýhodou zase hrozba ztráty dat v případě neočekávaného pádu systému a zřejmé nároky na paměť.
Existují dva podtypy In-Memory front. Můžou být implementovány formou spojového seznamu (LinkedList queue) nebo za použití pole ukazatelů na prvky fronty (FixedArray) s předem pevně určeným počtem prvků. FixedArray mode je nejrychlejší ze všech módů a je vhodný pro případy, kdy očekáváme pouze malý počet prvků ve frontě. Naproti tomu LinkedList queue dynamicky alokuje místo v paměti pro každou zprávu a je výhodný například na serverech, kde se očekává velký tok zpráv.

Třetí typ front představují Disk Queues, které jak z názvu vyplývá používají disk jako vyrovnávací paměť. Využití najdou v případech kdy si žádáme vysokou soplehlivost. Jejich nevýhodou je pomalost limitovaná rychlostí perzistentních úložišť.

Disk-Assisted Memory Queues fungují stejně jako In-Memory Queues a navíc v případě potřeby (kterou může být nedostatek místa nebo nutnost uložení zpráv z bufferu z nutnosti zálohy zpráv z perzistentní paměti před vypnutím systému) dokáží obsah fronty nebo její část přesunout na disk. Používají chytrý algoritmus, který při malém vytížení vůbec nepoužívá disk queues. V případě vyčerpání kapacity In-Memory fronty se algoritmus postará o přesun části zpráv do diskové fronty.

\subsubsection*{Rate-limiting za použití Rsyslog queues}
Původní řešení trápil neduh, kdy k vyprázdnění bufferu docházelo až s nově příchozí zprávou, což mělo za následek, že v případě zaplněného bufferu a následující delší odmlky nově příchozích zpráv mohlo dojít k velkému zpoždení odeslání zpráv v ten moment uložených v bufferu. Tento problém se nasazením Rsyslogu a použitím jeho sofistikovaných front vyřeší.
V této kapitole je popsána implementace fronty, která má za cíl škrtit tok odchozích zpráv podle stejných kritérií, jako tomu bylo původně.

Původní řešení bylo postavené na démonu BusyBox Syslogd doplněné o vlastní implementaci rate-limitingu zpráv a fungovalo následovně. Všechny příchozí zprávy putovaly do fronty o fixní velikosti 128 kB. V případě, kdy tok odchozích zpráv překročil 150 kbit/s nebo počet zpráv ve frontě přesáhl 800, byly nově příchozí zprávy zahozeny.

Rsyslog neumožňuje nastavení maximálního toku sítě, avšak poskytuje možnost nastavit pro frontu tyto parametry:
\begin{description}
  \setlength\itemsep{-1ex}
  \item [queue.size:] Maximální počet zpráv ve frontě.
  \item [queue.dequeuebatchsize:] Maximální počet zpráv vystupujících z fronty v jedné dávce.
  \item [queue.dequeueslowdown:] Zpoždění (v $\mu$s) mezi odesíláním dávek zpráv.
\end{description}

Queue.size je nově nastaven stejně na 800 zpráv.

Parametru Dequeuebatchsize byla přidělena hodnota 10. Z měření totiž bylo zjištěno, že průměrná velikost UDP paketu se zprávou ze STB má okolo 150~bytů. MTU UDP paketu je 1500~B. Deset 150-ti bytových paketů se zprávami v součtu odpovídá velikosti jednoho paketu běžně putujícího po síti a ty tak zaručeně nezpůsobí přetížení linky vlivem moc velkého objemu dat naráz.
Dále je hodnota okolo deseti výhodná z důvodu, že příliš malé Dequeuebatchsize vytěžuje CPU kvůli nutnosti častého vyprazdňování fronty. Naopak vysoké hodnoty parametru Dequeuebatchsize (v řádu stovek) způsobují nežádoucí, nárazové a velké objemy zpráv na lince. Deset tedy bylo zvoleno za kompromis.
  
Nyní je třeba zjistit hodnotu nastavit parametru Dequeueslowdown. Pomocí níže zobrazených vzroců bylo spočítáno požadované zpoždění v mikrosekundách, aby zátěž linky nepřekročila 150 kbit/s.

\begin{description}
	\item $\#~zpráv=\frac{šířka~pásma}{velikost~paketu}=\frac{150~*~1~000~[b]}{8~*~150~[b]}=125$
	\item $slowdown=\frac{1~sekunda}{\#~zpráv}=\frac{1~000~000}{125}*batchsize~=~8~000~*~10~=~80~000~[\mu$$s]$
\end{description}
Ještě zbývá zvolit typ fronty, kde kvůli důrazu na nízké využití zdrojů byla zvolena implementace používající fixní pole ukazatelů na zprávy.
Výsledný kód pro akci s In-memory frontou s nastaveným rate-limitingem vypadá následovně:
\begin{lstlisting}[style=RainerScriptSimpleStyle]
action(type="omfwd" target="192.168.1.10" port="5514" queue.size="800" queue.dequeueslowdown="80000" queue.dequeuebatchsize="10" queue.type="FixedArray" )
\end{lstlisting}

\subsection{Razítkování zpráv}
Požadavkem zadavatele bylo značit všechny zprávy vzestupnou řadou čísel kvůli rozpoznání případného výpadku některých zpráv.
Byl pro to použit modul mmsequence~\cite{RsyslogMmsequence}, který byl nastaven jako je ukázáno v kódu níže.
\begin{lstlisting}[style=RainerScriptSimpleStyle]
module(load="mmsequence")
action(	type="mmsequence"
		from="1"
		to="1048576" # 2^20
		var="$!counter" )
\end{lstlisting}
Proměnné \uv{\$!counter} je tak přiřazeno číslo \uv{1} a s každou další příchozí zprávou se číslo zvýší o \uv{1} dokud nenarazí na maximální hodnotu specifikovanou parametrem \uv{to}, kdy je číslo vyresetováno na původní hodnotu \uv{1}.
Tato proměnná je následně používána v šablonách a je tak připojena k tělu každé zprávy.

\subsection{Formát logů}
Požadavkem zadavatele je, aby zprávy měly identický formát, jako tomu bylo u původního řešení. Důvodem je, že logy ze STB sbírá vzdálený server, který očekává daný formát.
\\
\\
Vzor zprávy:
\begin{lstlisting}[style=RainerScriptSimpleStyle]
May  1 19:04:54 cc-b8-f1-04-17-89 solid: id=8853 Player Time [00:06:56.96]
\end{lstlisting}
Formát:
\begin{lstlisting}[style=RainerScriptSimpleStyle]
<PRI><RFC3164 date> <STB mac address> <component>: <id=NUM>  <message>
\end{lstlisting}

Je možno si povšimnout, že vzorová zpráva začíná datem a přitom formát zprávy obsahuje na prvním místě číslo PRI a až poté následuje datum. Hodnota PRI totiž není viditelná a slouží logovacímu démonu, který z ní dokáže vypočítat severity a facility zprávy.

\section{Moduly pro Rsyslog}
Rsyslog poskytuje podporu tzv. modulů, které mohou zásadně rozšiřovat jeho množinu funkcí. Tyto moduly jsou obvykle napsány v jednom C souboru. Pro jejich zprovoznění je třeba náležitě upravit Makefile a zkompilovat Rsyslog se zapnutou podporou pro ně.

Moduly se dělí na 6 základních kategorií, zde zmíním 3 nejpoužívanější:

\begin{description}
  \item [Output Modules:] Výstupní moduly umožňují posílat zprávy na různé cíle. Je tak možno implementovat například modul, který dokáže odesílat zprávy do nějaké exotické databáze, kterou Rsyslog v základu nezná. Jako příklad výstupního modulu zmíním ommail, což je modul sloužící k posílání zpráv skrze mail.
  \item [Input Modules:] Vstupní moduly, jak název napovídá, umožňují přijímat zprávy z různých zdrojů. Hojně používaný je imklog sbírající zprávy z linuxového jádra nebo imudp přijímající zprávy skrze UDP protokol.
  \item [Message Modification Modules:] Moduly, které modifikují obsah zprávy. Jako příklad uvedu v této práci použitý modul mmsequence, který generuje podle zadaných kritérií číselné řady.
\end{description}

V této práci byly naprogramovány dva moduly, oba z kategorie Message Modification Modules. V následujícím textu je popsán jejich účel a způsob použití. Implementaci zde v práci neuvádím, protože se většina kódu skládá z volání Rsyslog API a kód každého z nich obsahuje stovky řádků.

\subsection{Modul mmdelstr}
Tento modul slouží ke smazání zadaného podřetězce z těla zprávy.
\\
\\
Použití:
\begin{lstlisting}[style=RainerScriptSimpleStyle]
module(load="mmdelstr") 
action(type="mmdelstr" stringtobedeleted="Some string")
\end{lstlisting}

Modul má pouze jeden parametr \uv{stringtobedeleted}, kterým se specifikuje podřetězec, který má být smazán. V případě neexistence takového podřetězce zůstává zpráva netknutá. V případě výskytu vícero takových podřetězců je smazán pouze první.

\subsection{Modul mmsevrewrite}
Mmsevrewrite dokáže měnit severitu zadané zprávy. Rsyslog v základu funkci s takovou schopností nenabízí, protože se jedná o vzácný požadavek. Modul je použit v této práci pro konverzi zpráv pocházejících z aplikace používající s Rsyslogem jinak nekompatibilní množinu severit.
\\
\\
Použití:
\begin{lstlisting}[style=RainerScriptSimpleStyle]
module(load="mmsevrewrite")
action(type="mmsevrewrite" severity="debug")
\end{lstlisting}

Modul obsahuje pouze jeden parametr \uv{severity}, kterým se určuje nová severita zprávy. V případě zadání neplatné severity Rsyslog zaloguje chybovou hlášku a upravovaná zpráva zůstane v původním stavu.

\subsection{Postprocessing zpráv}
Zadavatel si přeje vytvoření ukázek pravidel pro RainerScript, které budou sloužit jako vzor, podle kterých si sám v budoucnu vytvoří sadu vlastních pravidel.

\subsubsection{Zahazování zpráv podle typu komponenty}
Pravidlo, které rozpozná zprávy podle zadané komponenty a obsahu zprávy a ty následně zahodí.
\\
\\
Implementace pravidla:
\begin{lstlisting}[style=RainerScriptStyle]
if $programname == 'solid' and \
$msg contains "Player_GetState" then
{	
	stop
}
\end{lstlisting}
Pokud zpráva pochází z komponenty \uv{solid} a obsahuje zmíněný podřetězec, klíčové slovo stop okamžitě zahodí v ten moment zpracovávanou zprávu.
\\
\subsubsection{Převod severit}
Některé aplikace běžící na STB používají jinou množinu severit, než s jakými pracuje Rsyslog a navíc nejsou v hlavičce zprávy, nýbrž v jejím těle.
Zadavatel proto požaduje severity zpráv extrahovat z jejich těl a nastavit je podle následující tabulky.

\begin{table}[H]
\centering
	\caption{Převodní tabulka severit}	\begin{tabular}{|l|l|}\hline
		Portal		& Syslog			\tabularnewline \hline \hline
		ERROR		& ERR			\tabularnewline \hline
		WARN		& WARN			\tabularnewline \hline
		INFO		& NOTICE			\tabularnewline \hline
		DEBUG		& INFO			\tabularnewline \hline
		TRACE		& DEBUG			\tabularnewline \hline
	\end{tabular}
\end{table}
Implementace pravidla:
\begin{lstlisting}[style=RainerScriptStyle]
if $msg contains "mTRACE: " then
{
	action(type="mmsevrewrite" severity="debug")
}
else if $msg contains "mDEBUG: " then
{
	action(type="mmsevrewrite" severity="info")
}
\end{lstlisting}
Zprávy obsahující nesprávně nastavené severity je možno opravit podle výše zmíněného pravidla. Bylo totiž vypozorováno, že ony postižené zprávy obsahují podřetězec ve formátu \uv{m<SEVERITY>: }. Stačí pak na danou zprávu zavolat akci mmsevrewrite s parametrem severity vyplněným podle převodní tabulky severit.

\subsubsection{Smazání podřetězce z těla syslog zprávy}
Zprávám pocházejícím z komponenty solid je třeba smazat zadaný podřetězec.
\\
\\
Implementace pravidla:
\begin{lstlisting}[style=RainerScriptStyle]
if $programname == 'solid' and $msg contains
		":[notificationFromPlayer]: INFO: " then
{
	action(type="mmdelstr" \ 
	stringtobedeleted=":[notificationFromPlayer]: INFO: ")
}
\end{lstlisting}


\section{Vzdálená konfigurace}
Požadavkem zadavatele je umožnit změnu nastavení maximální povolené severity jednotlivých komponent. Rsyslog neumožňuje změnu konfiguračního souboru za jeho běhu a proto je nutno implementovat API, které umožní přenastavení konfiguračního souboru a jeho znovunačtení (restartováním Rsyslogu).
Změny tímto skriptem způsobené musí být zachovány i po restartu STB.

\subsection{Návrh API}
Skript musí umět nastavit konfiguraci souboru rsyslog.conf tak, aby v případě rozpoznání zprávy od určité komponenty spolu s nastavenou severitou vyšší, než je povolená danou zprávu zahodil. 
Musí tedy umět v daném skriptu nalézt část kódu, kde se zpracovává zadaná komponenta a tuto část kódu vhodně upravit.

V úvahu připadaly 2 různé přístupy. Je možné při každém zavolání skriptu generovat celý nový konfigurační soubor a nebo pouze části souboru pomocí skriptu měnit.
Výhodou prvního způsobu je, že nehrozí nechtěné přepsání jiných čásí skriptu, než bylo zamýšleno. Nevýhodou je složitější implementace z důvodu nutnosti pří generování nového skriptu zohledňovat předchozí nastavení skritpu. Tedy by bylo nutno z původního skriptu extrahovat nastavení jednotlivých komponent a to zkombinovat s novým nastavením.
A proto byl zvolen 2. způsob řešení s tím, že zadavatel bude poučen o nutnosti dodržovat určité zásady při měnění konfiguračního souboru, aby nemohlo dojít k přepsání nesprávných částí souboru.

\subsection{Výběr implementačních nástrojů}
Jazyky jako Perl nebo Python se jeví jako ideální pro napsánání skriptu na zpracování textu. Tyto ani jiné podobné jazyky ovšem nejsou součástí SDK a zadavatel si nepřeje jejich instalaci z důvodu omezené paměti a nevalného výkonu embedded zařízení. Nezbýva, než se spokojit s na STB přítomnou minimalistickou BusyBox implementací SHELLu nesoucí název ASH. Ta sice neposkytuje tak elegantní syntaxi a nenabízí tolik schopností jako moderní SHELL-ové jazyky typu BASH, ale i přesto se s její pomocí a základních UNIXových programů jako například GREP je možno API naprogramovat.

\subsection{Rozhraní skriptu}
První možností je napsat API ve formě scriptu, který přijímá jednotlivé názvy komponent a jim příslušící maximální povolenou severitu jako parametry.

\begin{lstlisting}[style=RainerScriptSimpleStyle]
set_log_verbosity.sh [component1 severity1] ...
\end{lstlisting}

Jako druhá možnost připadá v úvahu skript, který čte seznam jednotlivých komponent a maximálních povolených severit ze souboru, který má následující formát:

\begin{lstlisting}[style=RainerScriptSimpleStyle]
component1  = DEBUG
componentXY = INFO
...
DEFAULT     = INFO
\end{lstlisting}

V implementaci byl nakonec použit první způsob pro jeho jednoduší obsluhu a navíc s jeho použitím pro zadavatele odpadá starost o další konfigurační soubor.

\subsection{Implementace API}
Skript na vstupu očekává sudý počet parametrů, kde každý sudý parametr je název komponenty a liché parametry slouží pro definování severit pomocí jejich číselných hodnot.
Skript vyhledá v konfiguračním souboru rsyslog.conf řádek s danou komponentou a přenastaví maximální povolenou severitu. Skript kontrolojue správnost vstupních parametrů pro zabránení neočekávaného chování programu.


\chapter{Testování}
V této kapitole jsou předvedeny tři typy testů.
Nejprve se sleduje využití linky sítě při simulaci běžného provozu STB. Druhý test ověřuje funkčnost rate-limitingu zpráv. A v posledním testu se zkoumá vytížení prostředků STB za běžných i extrémních podmínek.

Vždy je porovnáváno nové řešení postavené na Rsyslogu oproti původnímu a následuje diskuze.

\section*{Testovací prostředí a nástroje}

\subsection*{WireShark}
Tento nástroj slouží jako analyzér síťového provozu. Dokáže v reálném čase zachytávat informace o paketech putujících po síti a ty následně vyzobrazit v grafu, čehož je v oddílech 5.1 a 5.2 využito.

\subsection*{Testovací syslog server}
Pro účely testování byla nakonfigurována lokální síť jakožto simulace reálných serverů provozovatele. Jako syslog server byl použit notebook Apple Macbook Pro, na kterém byl nakonfigurován logovací démon Syslog-ng pro sběr logů z STB.

\section{Test využití linky zprávami za běžného provozu}
 V tomto testu je srovnáváno vytížení linky za použití nového a starého logovacího řešení při běžném provozu STB. 

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.44]{images/test-1h-syslogd-default}
	\caption[Syslogd]{Syslogd}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.44]{images/test-1h-rsys-default}
	\caption[Rsyslog]{Rsyslog}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.44]{images/test-1h-rsys-solidoff}
	\caption[Rsyslog - aplikace Solid vypnuta]{Rsyslog - aplikace Solid vypnuta}
\end{figure}

\subsection*{Zhodnocení}
Jak je vidět z prvních dvou grafů (obr. 5.1 a 5.2), nové řešení postavené na Rsyslogd přijíma méně logů. Je to způsobeno jeho konfigurací, v níž je nastaveno pravidlo (viz kapitola 4.3.3.1), kterým se zahazují určité nepotřebné zprávy. Na STB totiž běží aplikace, již zadavatel nemá možnost upravit, která loguje mimo jiné i nepotřebné zprávy. V původním řešením podobné pravidlo nebylo možné jakkoliv nastavit.
Dle Wiresharku tak nové řešení v průměru přijíma 8,6 paketů za sekundu oproti 9 paketům za sekundu v původním řešení.

V třetím grafu (obr. 5.3) je pro zajímavost znázorněno využití linky při použití nového řešení po zakázání zpráv od komponenty solid.
Chci tím demonstrovat, že zadavatel má v novém řešení možnost si upravit filtrování zpráv podle různých kritérií a může tak razantně snížit tok zpráv na síti.

\section{Test rate-limitingu zpráv}
Jak bylo zjištěno v minulém testu, zprávy generované set-top boxem tvoří tok o přibližně deseti tisících bitech za sekundu. Limit toku je nastaven na 15-ti násobek této hodnoty a tak by se v reálných podmínkách neměl nikdy aktivovat. Nicméně zadavatel rate-limiting požaduje jako pojistku pro případ, kdy by například vlivem chyby některá z komponent začala generovat nepřiměřené množství zpráv a nedošlo tak k zahlacení ať už sítě na straně uživatele STB nebo serverů provozovatele.

Pro ověření funkčnosti rate-limitingu byl proto sestrojen následující skript.

\subsection{Skript pro otestování rate-limitingu}
Účelem skriptu je generovat takové množství zpráv, aby na síti vznikl tok přesahující 150~000 b za sekundu a tedy aby logovací démon byl nucen zprávy bufferovat.

Skript je řešen tím způsobem, že je v deseti paralelních instancích zavolán for-cyklus, každý generující po tisíci zprávách.
Zprávy mají konstantní velikost 60 B, což odpovídá délce průměrné zprávy generované set-top boxem.

\begin{lstlisting}[style=AshStyle]
gen_messages() {
	for i in $(seq 1000); do
		logger 	"Lorem ipsum dolor sit amet, consectetuer adipiscing elit."
	done
}

for i in $(seq 10); do
	gen_messages &
done
\end{lstlisting}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.36]{images/test-rateLim-rsyslog-Buff-off}
	\caption[Rsyslog - vypnutý Rate-limiting]{Neomezovaný tok zpráv generovaný skriptem}
\end{figure}
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.36]{images/test-rateLim-syslogd}
	\caption[Syslogd - zapnutý Rate-limiting]{Syslogd - zapnutý Rate-limiting}
\end{figure}
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.36]{images/test-rateLim-rsyslog}
	\caption[Rsyslog - zapnutý Rate-limiting]{Rsyslog - zapnutý Rate-limiting}
\end{figure}

\subsection{Zhodnocení}
První graf (obr. 5.4) znázorňuje kolik bitů textu za sekundu daný skript ve skutečnosti generuje. Graf vznikl použitím Rsyslogu s deaktivovaným Rate-limitingem zpráv.
Zbylé dva grafy (obr 5.5 a 5.6) pouze demonstrují správnou funkčnost rate-limitingu. Tedy, že tok bitů za sekundu nepřekročí hranici 150~000.

\section{Test vytížení systému}
Protože embedded zařízení neoplývají vysokým výkonem a ani v této práci použitý STB není vyjímkou, je nutno logovací řešení podrobit testům a zjistit jeho chování pod extrémím zatížením, zda nehrozí jeho přetížení a z toho vyplývající nestabilita. Dále je otestováno i vytížení systému za běžných podmínek, kde je porovnáno s původním řešením. V testech se zkoumá vytížení CPU a paměťová náročnost.

Před samotným testováním je ale nutno čtenáře seznámit se základními pojmy týkajícími se měření výkonosti CPU v Linuxových systémech~\cite{MeasuringPerformance}.

\subsection{Terminologie}

\begin{description}
\setlength\itemsep{-1ex}
	\item [Clock tick:] Clock tick je jednotka pro měření CPU času.
	\item [CLK\_TCK:] Makro (může mít i jiný název jako např. CLOCKS\_PER\_SEC) definující počet clock ticků za sekundu. Na našem STB má hodnotu 100.
	\item [CPU time (CPU čas):] Představuje dobu, kterou procesor strávil vykonáváním procesu vyjádřenou počtem clock ticků nebo v sekundách získaných vydělením clock ticků hodnotou makra CLK\_TCK.
	\item [User time:] CPU čas strávený vykonáváním procesu v \uv{user režimu}. V tomto řežimu proces nemá oprávnění provádět privilegované operace které mohou ovlivnit celý systém.
	\item [System time:] CPU čas strávený vykonáváním instrukcí procesu v \uv{kernel režimu}. V tomto řežimu jádro systému provádí privilegované operace vyžádané procesem.
	\item [Real time:] Čas doby běhu procesu v sekundách. Jedná se o absolutní dobu běhu programu a je v ní tedy i zahrnuta doba, kdy byl proces blokován nebo kdy se dělil o prostředky CPU s jinými procesy.
	\end{description}

\subsection{VFS /proc}
V Linuxových systémech existuje virtuální souborový systém /proc~\cite{procFilesystem}, který v jednotlivých podsložkách a souborech shromažďuje informace o HW systému a procesech v něm běžících.

Informace o stavu procesu shromažďuje soubor /proc/<pid>/stat/ (pid značí číselný identifikátor zkoumaného procesu), který je ve formě textového řetězce obsahujícího informace o procesu. Pro tuto práci důležité informace z tohoto souboru jsou zobrazeny a popsány v následující tabulce. Čísla v závorkách představují jejich pozice v řetězci.

\begin{description}
\setlength\itemsep{-1ex}
	\item [utime:] CPU čas strávený vykonáváním procesu v user režimu. (14)
	\item [stime:] CPU čas strávený vykonáváním procesu v kernel režimu. (15)
	\item [cutime:] CPU čas strávený čekáním na potomky procesu v user režimu. (16)
	\item [cstime:] CPU čas strávený čekáním na potomky procesu v kernel režimu. (17)
	\item [starttime:] CPU čas vyjadřující moment startu procesu. (22)
\end{description}

\subsection{Vytížení CPU syslog démonem při velké zátěží}
V tomto testu je měřeno procentuální vytížení CPU při extrémních podmínkách. Ty jsou simulovány skriptem z kapitoly 5.2.1, který generuje velké množství zpráv a zahlcuje tak logovacího démona. 

\subsection*{Skript pro získání vytížení CPU}
Skript měří počet clock ticků sledovaného logovacího démonu po dobu, kdy je zatížen zpracováním zpráv z paralelně spuštěného skriptu na generování zpráv z kapitoly 5.2.1. Poměr takto získanách clock ticků ku celkovému CPU času skriptu genMessages.sh potom představuje procentuální vytížení procesoru daným logovacím démonem.

\begin{lstlisting}[style=AshStyle]
sfile=/proc/$1/stat
if [ ! -r $sfile ];
	then echo "pid $1 not found in /proc"; exit 1;
fi
start=$(cat $sfile| awk '{sum=$14+$15+$16+$17; print sum}')
time ./genMessages.sh 2> timeOut && \
stop=$( cat $sfile| awk '{sum=$14+$15+$16+$17; print sum}')

sysTime=$(cat timeOut | grep sys | awk '{print $3}' | tr -d 's')
userTime=$(cat timeOut | grep user | awk '{print $3}' | tr -d 's')
rm -rf timeOut
clockTicks=$((stop-start))

getMilisec()
{
	 sec=$(echo $1 | cut -d'.' -f1)
	 miliSec=$(echo $1 | cut -d'.' -f2)
	 echo $((miliSec*10+sec*1000))
}

sysTimeMiliSec=$(getMilisec "$sysTime")
userTimeMiliSec=$(getMilisec "$userTime")
timeMiliSec=$((sysTimeMiliSec+userTimeMiliSec))

cpuUsage=$((clockTicks*1000*1000/timeMiliSec))
echo CPU Usage: $cpuUsage
\end{lstlisting}

\subsection*{Výsledky měření}
Vítězně z tohoto testu jednoznačeně vychází Syslogd, který si pro svůj chod vyžádá pouhé 3,12 \% CPU výkonu. Oproti tomu Rsyslog spotřebuje skoro čtyř násobek prostředků, celkem 11,9 \% CPU výkonu.
Výsledek nijak nepřekvapuje, jelikož Syslogd filtruje zprávy pouze na základě severity a facility. Rsyslog zkoumá více parametrů zprávy (v některých případech dokonce analyzuje samotný text zpráv, což je výpočetně náročná operace) a navíc pro každou zprávu volá externí modul mmsequence.

Skoro dvanácti procentní vytížení CPU výkonu Rsyslogem je však v pořádku a to z důvodu, že zbylé procesy běžící na STB vytěžují CPU minimálně (dohromady v jednotkách  procent) a tak STB i v této situaci běží naprosto nerušeně.

Nutno dodat, že situace, která byla tímto testem simulována, by v reálném nasazení neměla nikdy nastat.

\subsection{Dlouhodobé vytížení CPU syslog démonem}
V tomto testu je testováno využití CPU jednotlivými logovacími démony za běžného provozu STB.

\subsection*{Skript}
Dlouhodobé procentuální vytížení CPU logovacím démonem je získáno vydělením počtu clock ticků démonu dobou v sekundách, po kterou byl spuštěn.

\begin{lstlisting}[style=AshStyle]
sfile=/proc/$1/stat
if [ ! -r $sfile ]; then
    echo "pid $1 not found in /proc"; exit 1;
fi

totalTime=$(cat $sfile| awk '{sum=$14+$15+$16+$17; print sum}')
upTime=$(cat /proc/uptime | tr '.' ' ' | awk '{print $1}')
startTime=$(cat $sfile| awk '{print $22}')
seconds=$((upTime-(startTime/CLK_TCK)))

cpuUsage=$((totalTime*1000/seconds))
echo Usage of CPU by Process PID: $1 is: $cpuUsage
\end{lstlisting}
Aby výsledky testu měly vypovídající výpovědní hodnotu, byl STB s běžícím logovacím démonem nechán zapnutý po dobu jedné hodiny a až následně byl spuštěn skript.

\subsection*{Výsledky měření}
Z měření bylo zjištěno, že Syslogd vytěžuje CPU z 0,051~\% a Rsyslogu stačí v průměru pouze 0,042~\%~CPU výkonu. Z tohoto zjištění tak vyplývá, že Rsyslog je velice nenáročný co se nároků na zdroje CPU týče, jeho chod tak neovlivní ostatní aplikace běžící na STB a zadavatel ho může bez obav nasadit.

\subsection{Paměťová náročnost}
Množství procesem využívané paměti se v systémech postavených na linuxovém jádru dá zjistit ze souboru /proc/<pid>/statm. V tomto textovém souboru se na druhé pozici nachází proměnná RSS, jež udává využívané místo v paměti daným procesem.


\begin{conclusion}
Cílem práce bylo rozšířit logovací řešení STB o možnost vzdálené konfigurace filtrování zpráv pro umožnění snížení objemu odesílaných logů.

Z analýzy vyplynulo jako nejvhodnější řešení nahrazení stávajícího BusyBox Syslog démonu modernějším Rsyslog démonem spolu s implementací podpůrných skriptů a modulů pro Rsyslog.
 
Bylo tak naprogramováno API pro vzdálenou konfiguraci, jež dovoluje technikům měnit konfiguraci logování. V práci dále vznikly dva moduly pro Rsyslog. Jeden z nich (mmsevrewrite) slouží ke změně severit zpráv, jež je chybějící a přitom žádanou funkcí Rsyslogu~\cite{rsysMailingList} a proto je v plánu ho v budoucnu nabídnout k přijetí do samotného projektu Rsyslog.

Touto prací dostal zadavatel do rukou nástroj, kterým může díky širší podpoře filtrovacích pravidel, než tomu bylo v původním řešení, razantně snížit objem zpráv putujících na servery.

V průběhu realizace bylo odhaleno nedůsledné označování zpráv generovaných aplikacemi zadavatele nesprávnou severitou. Po přiřazení správných severit dodané řešení umožní dosáhnout ještě lepšího poměru vyfiltrovaných zpráv.

Veškerý kód napsaný v této práci byl psán s ohledem na přenositelnost a proto je možné ho nasadit na různých typech set-top boxů s OS Linux.

Díky použití Rsyslogu může zadavatel v budoucnu zvážit nahrazení stávajícího  transportního protokolu UDP pro Rsyslog na míru navrženým protokolem RELP~\cite{RsyslogRELP}, který zaručuje spolehlivý přenos zpráv a umožňuje jejich šifrování. Tato práce se jím nezabývala z důvodu nutnosti změny infrastruktury.

\end{conclusion}

\bibliographystyle{csn690}
\bibliography{mybibliographyfile}

\appendix

\chapter{Seznam použitých zkratek}
\begin{description}
	\item[API] Application Programming Interface
	\item[ASH] Almquist Shell
	\item[CPU] Central Processing Unit
	\item[DMD] Download manager daemon
	\item[GPU] Graphics processing unit
	\item[IPTV] Internet Protocol Television
	\item[OS] Operating system
	\item[PC] Personal computer
	\item[PID] Process ID
	\item[MTU] Maximum Transmission Unit
	\item[RAM] Random Access Memory
	\item[RFC] Request for Comments
	\item[RSS] Resident Set Size
	\item[SDK] Software Development Kit
	\item[STB] Set-top Box
	\item[VFS] Virtual File System
\end{description}

\chapter{Obsah přiloženého CD}

\begin{figure}
	\dirtree{%
		.1 readme.txt\DTcomment{stručný popis obsahu CD}.
		.1 exe\DTcomment{adresář se spustitelnou formou implementace}.
		.1 src.
		.2 impl\DTcomment{zdrojové kódy implementace}.
		.2 thesis\DTcomment{zdrojová forma práce ve formátu \LaTeX{}}.
		.1 text\DTcomment{text práce}.
		.2 thesis.pdf\DTcomment{text práce ve formátu PDF}.
		.2 BP\_Vavricka\_David\_2016.pdf\DTcomment{text práce ve formátu PDF}.
	}
\end{figure}

\end{document}
