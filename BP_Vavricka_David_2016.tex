\documentclass[thesis=B,czech]{FITthesis}[2012/06/26]

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{dirtree}
\usepackage{float}
\usepackage{listings}

\lstset{basicstyle=\ttfamily,
	showstringspaces=false,
	commentstyle=\color{red},
	keywordstyle=\color{blue}
}

\department{Katedra softwarového inženýrství}
\title{Flexibilní logování pro embedded Linuxové systémy}
\authorGN{David}
\authorFN{Vavřička}
\authorWithDegrees{David Vavřička}
\supervisor{Ing. Matěj Laitl}
\acknowledgements{Doplňte, máte-li komu a za co děkovat. V~opačném případě úplně odstraňte tento příkaz.}
\abstractCS{Doplňte}
\abstractEN{Sem doplňte ekvivalent abstraktu Vaší práce v~angličtině.}
\placeForDeclarationOfAuthenticity{V~Praze}
\declarationOfAuthenticityOption{4} %volba Prohlášení (číslo 1-6)
\keywordsCS{logování, vestavěné systémy, logovací démoni, Linux, Rsyslog}
\keywordsEN{logging, embedded systems, logging daemons, Linux, Rsyslog}

\begin{document}

\begin{introduction}

\end{introduction}

\chapter{Technické požadavky}
Cílem je upravit logovací řešení pro set-top box EKT DID7006mTF~\cite{ekt7006} tak, aby splňovalo technické požadavky popsané v této kapitole. Řešení musí fungovat a být otestováno na zmíněném modelu set-top boxu a pokud možno by mělo být přenositelné i na jiné typy set-top boxů.
Požadavky jsou rozděleny na základní a rozšířené. Rozšířené požadavky není nutno implementovat.

\section{Základní technické požadavky}

\subsection{Snížení objemu logů}
Je žádoucí umožnit snížit objem zasílaných logů z důvodu přílišného zatížení sítě a serverových disků. A to tak, že zadavatel bude schopen nadefinovat pro každou komponentu úroveň severity zpráv, od které mají být posílány na server. Výchozí nastavení dodá zadavetel.

\subsection{Vzdálená konfigurace}
Technické řešení musí být schopno za běhu pomocí SHELL-ového API měnit minimální severitu zpráv pro jednotlivé komponenty a dále toto API musí umožnit nastavit výchozí severitu, která se použije pro komponenty ji nemají explicitně nastavenou. Takto změněné nastavení musí být perzistentní i po restartu STB. Výchozí nastavení se obnoví až po factory resetu. API navrhne dle své libovůle sám řešitel.

\subsection{Rate-limiting odesílaných zpráv}
Nové logovací řešení musí být schopné provádět rate-limiting odesílanych zpráv tak, aby nepřekročilo maximální vyhrazenou šířku pásma. Bude umožněno nastavit jak dlouhodobé tak krátkodobé limity. Naivní rate-limiting je i v existujícím řešení, řešitel navrhne výchozí nastavení nového řešení tak, aby přibližně odpovídalo současnému chování. 

\subsection{Formát logů}
Je nutno zachovat formát logů jako ho má původní řešení, aby se jednalo o drop-in replacement bez nutnosti jakkoli měnit konfiguraci serveru, který sbírá logy od set-top boxů.

\subsection{Razítkování zpráv}
Každé zprávě se musí přidat textový prefix id=N, kde N monotonicky roste s každou zprávou.  To slouží pro detekci ztracených zpráv. Id přeteče po 32 nebo 64 bitech, to záleží na rozhodnutí řešitele. Po rebootu STB id znovu začíná od 1.

\subsection{Post-processing zpráv}
Zadavatel má pouze částečnou kontrolu nad zprávami generovanými aplikacemi na set-top boxu, například nedokáže ve všech případech eliminovat dlouhé prefixy u zpráv. Je proto nutno takové prefixy rozpoznat a vhodně odfiltrovat před odesláním. Ze stejného důvodu mají některé zprávy nevhodně vyplněnou severitu a položku app-name. Jejich správné hodnoty jsou uloženy v textu zprávy, jejíž formát je pro jednotlivé skupiny zpráv konstantní. Řešení bude schopné tyto údaje z těla zprávy extrahovat a nahradit jimi původní metadata. Tato pravidlo musí být možné definovat a měnit bez nutnosti nového sestavení softwaru. 
Řešitel vytvoří pro ukázku 3 pravidla, která budou sloužit zadavateli jako šablony pro možná budoucí filtrovací pravidla. Tato pravidla jsou popsána v kapitole analýza.

\section{Rozšířené technické požadavky}

\subsection{Komprese zpráv}
Bylo by vhodné zvážit pro a proti komprese zpráv. Vyplatí se ušetřená přenesená data oproti režiji spojené s kompresí a dekompresí zpráv?

\subsection{Integrace do existující servisní C++ komponenty}
Zadavatel na STB provozuje malého démona dmd napsaného v C++, který mimo jiné obsahuje minimalistický HTTP webserver. Dále v browseru běží Javascript aplikace (nangu.TV portál), která pomocí messagingu komunikuje s centrálním serverem. Tato Javascript aplikace ovšem nemůže přímo používat Shell API.
Požadavkem je rozšířit C++ komponentu dmd tak, aby umožnila Javacript aplikaci řídit konfiguraci logování (viz bod Vzdálená konfigurace).

\chapter{Logování v linuxových systémech}
Systémoví administrátoři nakládají s kvanty nejrůznějších zpráv (logů) pocházejících ať už přímo z daného systému, od jednotlivých systémových komponent nebo dokonce i z jiných vzdálených systémů. Pro jejich snažší správu slouží na UNIX-ových a tedy i LINUX-ových systémech tzv. Syslog. Tím je myšleno Syslog API skrze které se odesílají jednotlivé zprávy na standardizovaný socket /dev/log. Dále je tím myšlen Syslog démon spravující jednotlivé logy. A konečně syslog protokol, tedy specifikace určující formát zpráv nebo také například způsob transportu zpráv po síti.

\section{Syslog démon}
Démon je v UNIXovém světě označení pro takový proces, který oproti běžným procesům neintereaguje přímo s uživatelem, ale běží na pozadí operačního systému a funguje samostatně. Hlavním účelem syslog démona je sběr logů od ostatních procesů, které následně v závislosti na jeho konfiguraci dokáže filtrovat a ukládat na disk či odesílat na požadovaný vzdálený server.

\section{Syslog formát zpráv}
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{images/syslog-message-format}
	\caption[Formát syslog zprávy]{Formát syslog zprávy}
\end{figure}

Syslog zpráva se skládá ze 3 částí jak je pro lepší představu graficky vyobrazeno na obrázku výše.

V části zvané PRI (priorita) se skrývájí dvě číselné hodnoty facility a severity. Facility určuje zdroj logů a severity jejich důležitost (tedy zda se jedná například pouze o debug hlášku a nebo naopak o důležitou zprávu například o pádu programu). Na základě těchto dvou hodnot syslog démon provádí základní filtraci zpráv.  
Se severitou a facilitou zpráv se budeme v této práci častokrát setkávat a proto jsou na konci kapitoly umístěny tabulky jejich hodnot.

V části zvané HEADER (hlavička) nalezneme časovou značku a hostname nebo IP adresu zdrojového zařízení dané zprávy.
Část MSG již obsahuje text samotné zprávy.

Tyto zprávy obvykle po síti putují skrze skrze UDP protokol, jelikož obvykle upřednostuňujeme rychlost nad spolehlivostí. Syslog standard omezuje velikost paketu zprávy na maximální velikost 1024 Bytů.

\section{Syslog protokol}
Syslog protokol~\cite{NetworkAdmSurGuide} spatřil světlo světa již v roce 1980. Má ho na svědomí Eric Allman, který ho psal s úmyslem využít ho pro potřeby Sendmail projektu. Nicméně postupem času byl tento protokol díky skvělému návrhu a díky své jednoduchosti adaptován i jinými projekty. Rozšířil se na různé OS a později se stal standardem pro logování na většině Unixových systémů.
Tento protokol poskytuje možnost zařízením posílat notifikační zprávy (logy) ať už skrze sít a nebo lokálně v rámci jednoho zařízení na syslog server, kterým je již v minulé kapitole zmíňený syslog démon.

\subsection{The BSD syslog Protocol - RFC 3164}
Až po přibližně 20-ti letech od vzniku syslog protokolu sepsal Chris Lonvick dokument RFC3146~\cite{RFC3164} popisující daný protokol. Do té doby existovala velká spousta v detailech se lišících implementací, což mělo za následek v jistých případech nekompatibilitu. Dokument čítá celkem 19 stránek kde je především detailně popsán formát a parametry zpráv.

\subsection{The Syslog Protocol - RFC 5424}
Oficiální standard vznikl až s příchodem Syslog protokolu RFC 5424, který světu představil v roce 2009 jeho autor Rainer Gerhards. Počet stránek se rozrostl na 37 a došlo k některým zásadním a velice užitečným změnám.

Nový standard umožňuje použití libovolného trasnportního protokolu~\cite{RFC5424-TrProt}, oproti RFC 3164, kde je jako transportní protokol pevně určeno UDP~\cite{RFC3164-UDP}.
Mírných změn doznal také formát zpráv, který je možno strukturovaně rozšířovat dle specifických potřeb~\cite{RFC5424-MsgForm}.

V této práci je vžy při zmíňce o syslog protokolu myšlen standard RFC 5424.

\begin{table}[ht]
\centering
	\caption[Tabulka severit podle RFC 5424]{Seznam severit dle RFC 5424.~\cite{RFC5424}}
	\begin{tabular}{|l|l|l|}\hline
		Číselný kód	& Severity & Význam	\tabularnewline \hline \hline
		0		& Emergency	&	System is unusable. \tabularnewline \hline
		1		& Alert		&	Action must be taken immediately. \tabularnewline \hline
		2		& Critical	&	Critical conditions. \tabularnewline \hline
		3		& Error		&	Error conditions.	\tabularnewline \hline
		4		& Warning	&	Warning conditions. \tabularnewline \hline
		5		& Notice		&	Normal but significant condition. \tabularnewline \hline
		6		& Informational & Informational messages. \tabularnewline \hline
		7		& Debug		&	Debug-level messages. \tabularnewline \hline
	\end{tabular}
\end{table}

\begin{table}[ht]   %[H] místo [ht] aby to bylo přesně na daném místě
\centering
	\caption[Tabulka facilit podle RFC 5424]{Seznam facilit dle RFC 5424.~\cite{RFC5424}}
	\begin{tabular}{|l|l|}\hline
		Číselný kód & Facility			\tabularnewline \hline \hline
		0		& kernel messages		\tabularnewline \hline
		1		& user-level messages	\tabularnewline \hline
		2		& mail system			\tabularnewline \hline
		3		& system daemons			\tabularnewline \hline
		4		& security/authorization messages			\tabularnewline \hline
		5		& messages generated internally by syslogd	\tabularnewline \hline
		6		& line printer subsystem		\tabularnewline \hline
		7		& network news subsystem		\tabularnewline \hline
		8		& UUCP subsystem			\tabularnewline \hline
		9		& clock daemon			\tabularnewline \hline
		10		& security/authorization messages			\tabularnewline \hline
		11		& FTP daemon				\tabularnewline \hline
		12		& NTP subsystem			\tabularnewline \hline
		13		& log audit				\tabularnewline \hline
		14		& log alert				\tabularnewline \hline
		15		& clock daemon			\tabularnewline \hline
		16		& local use 0			\tabularnewline \hline
		17		& local use 1			\tabularnewline \hline
		18		& local use 2			\tabularnewline \hline
		19		& local use 3			\tabularnewline \hline
		20		& local use 4			\tabularnewline \hline
		21		& local use 5			\tabularnewline \hline
		22		& local use 6			\tabularnewline \hline
		23		& local use 7			\tabularnewline \hline
	\end{tabular}
\end{table}

\chapter{Analýza a návrh}
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{images/diagram-nasazeni-puvodniho-reseni}
	\caption[Diagram nasazení původního řešení]{Diagram nasazení původního řešení}
\end{figure}

\section{Současné řešení}
V této kapitole jsou uvedeny a popsány jednotlivé pro tuto práci důlužité komponenty současného řešení.

\subsection{HW specifikace STB EKT DID7006}
\begin{description}
  \item [CPU:] ARM 9 Ali M3733
  \item [GPU:] Mali 400
  \item [RAM:] 512MB DDR3
  \item [Perzistentní paměť:] 512MB NAND Flash
\end{description}

\subsection{Runtime prostředí}
Na STB běží OS GNU/Linux s Busybox sadou aplikací, která nahrazuje standardní GNU shellové utility. Busybox aplikace jsou díky své malé velikosti vhodnější pro embedded zařízení. Na druhou stranu neobsahují všechny funkcionality a možnosti nastavení.

\subsubsection{Browser}
Browser je jednoduchý internetový prohlížeč dodaný výrobcem STB.
V něm běží v Javascriptu zadavatelem napsaná aplikace poskytující uživatelské rozhraní. Mimo to také naslouchá zprávám z aplikačního serveru, na jejichž základě může provádět akce, a to včetně generování POST či GET requestu pro démon dmd.
Tato javascriptová aplikace spolu s dalším podpogramem nesoucím název player generují velké množství logů. Tyto logy nepoužívají standardizovanou syslog množinu severit, ale svou vlastní s ní nekompatibilní. Logovací démon ovšem očekává zprávy právě podle syslog standardu. Implementaci browseru ani playeru nemůže zadavatel měnit a proto je třeba nekompatibilitu vyřešit pomocí logovacího démonu.

\subsubsection{Servisní komponenta dmd}
Dmd je v C++ napsaná servisní komponenta, která zprostředkovává komunikaci mezi Browserem a shellovým prostředím pomocí minimalistického HTTP serveru. Umožňuje JavaScript aplikaci na STB provádět operace, které jsou dostupné jen z shellového API.

\subsubsection{BusyBox Syslogd}
Jedná se o minimalistický logovací démon, který je podrobněji popsán v následující kapitole \uv{Srovnání logovacích démonů}.
Zadavatel mu pro své potřeby navíc doimplementoval číslování jednotlivých zpráv pro rozpoznání výpadku a za druhé naivní rate-limiting zpráv. Ten je naivní z důvodu, že používá statický buffer na počet zpráv, který nebere ohled na jejich velikost a hlavně bufferované zprávy se neodešlou samy, ale jen s nově příchozími zprávami.
Za použití tohoto démonu není možné splnit některé stěžejní technické požadavky, jako například \uv{Snížení objemu logů} nebo \uv{Post processing zpráv}. Proto bude nutné ho nahradit nějakým vyspělejším démonem. Tím se ale zabývá až další kapitola \uv{Nové řešení}.

\subsection{Aplikační server}
Aplikační server se stará o business logiku, například poskytuje uživateli práva přehrát daný kanál nebo film, komunikuje s javascriptovou aplikací, která se vůči němu autorizuje a podobně.
AS není možné v této práci jakkoli měnit. Je nutné zachovat kompatibilitu.

\subsection{Servery pro sběr logů}
Zadavatel provozuje cluster serverů sbírajících logy od statisíců STB. Běží na nich rsyslog nakonfigurovaný pro co nejlepší výkonost.


\section{Vývoj pro STB}
\subsection{Buildovací systém Gu}
Gu je buildovací systém pro linuxová embedded zařízení, který si klade za cíl zjednodušit a urychlit buildovací proces. Gu využívá balíčkovací systém pacman (převzatý z Arch Linuxu) a nástroj scratchbox2 sloužící k zjednodušení cross-kompilace. Tyto 2 nástroje jsou skryty v konzolovém přikazu \uv{gu}, kterým se celé Gu ovládá.

\subsection{PKGBUILD}
Jedná se o shellový script obsahující informace potřebné pro build jednotlivých aplikací systémem Gu. Níže je pro představu uveden vzorový script:
\begin{scriptsize}
\begin{verbatim}
pkgname=libee
pkgver=0.4.1
pkgrel=1
arch=('armv7h' 'armv7sp')
depends=('libestr')

build() {
    cd ${pkgname}-${pkgver}
    PKG_CONFIG_PATH=/mnt/hdd_1/lib/pkgconfig
    ./configure --prefix=/mnt/hdd_1
    make V=1
}

package() {
    cd ${pkgname}-${pkgver}
    make install DESTDIR=${pkgdir}
}
\end{verbatim}
\end{scriptsize}

Povinná pole jsou \uv{pkgname}, označující název balíčku, \uv{pkgver} pro určení jeho verze, \uv{pkgrel} sloužící k označení verze PKGBUILD scriptu a \uv{arch} definující cílové architektury.
 Script dále obsahuje funkce zajišťující build a instalaci balíčku. Každý PKGBUILD musí obsahovat minimálne funkci package(), která nainstaluje soubory do cílové složky. Užitečnou funkcí je funkce build() sloužící k přípravě a kompilaci zdrojových kódů před samotnou jejich instalací.

\section{Nové řešení}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{images/diagram-nasazeni-noveho-reseni}
	\caption[Diagram nasazení nového řešení]{Diagram nasazení nového řešení}
\end{figure}

Prvně je nutno zvážit, zda problém řešit na straně serveru nebo set-top boxu. Vhodnou konfigurací logovacího démona na straně serveru, který by nepotřebné zprávy zavčas rozpoznal, zahodil a dále nezpracovával bychom splnili požadavek na snížení zátěže serverových disků. Přetížení sítě se takto vyřešit ale nedá a proto toto řešení zavrhuji.
Je tedy nutno problém řešit na straně set-top boxu kde původní řešení je postaveno na busy-box syslogd. Nabízí se možnost upravit fungování tím způsobem, aby se logy s nízkou severitou už na set-top boxu zahazovaly a pouze v případě potřeby bylo umožněné na dálku změnit konfiguraci démona tak, aby se povolilo logování pro logy s nastavenou danou komponentou a severitou. To vše přes SHELL-ové API.
Součástí zadání je ale i implementovat škrcení zpráv, aby nedocházelo k zahlcení linky. Takovou možnost prostý syslogd neposkytuje a je proto nutno zvážit napsání vlastního démona či nasazení jiného, vyspělejšího logovacího démona.


\section{Srovnání logovacích démonů}
V této kapitole zmíním a popíši vybrané logovací démony a v závěru kapitoly je porovnám.

\subsection{BusyBox Syslogd}
Tato logovací utilita se skládá ze dvou démonů, jmenovitě z Klogd, který zachytává logy z kernelu a předává je ke zpracování Syslogdémonu. Syslogd pak zachytává i všechny zbylé logy a dále s nimi nakládá. Má však velice omezenou funkcionalitu. Dokáže pouze logy lokálně ukládat, přeposílat je dále po síti, zahazovat duplikáty, rotovat logy v závislosti na velikosti a filtrovat zprávy podle omezených kritérií. Dokáže totiž filtrovat pouze podle typu facility a už nikoliv podle názvu komponenty, která log vygenerovala.

\subsection{Syslog-ng}
Flexibilní logovací démon zaměřený na centralizované a zabezpečené logování. Má široké možnosti nastavení a poskytuje obrovské množství funkcionalit. Takže jeho vhodným nakonfigurováním se dají snadno splnit všechny vytyčené technické požadavky až na požadavek pro možnost vzdálené změny konfigurace.
Je nutno ale zmínit, že pokročilé funkce jako například šifrování zpráv, bufferování nebo message-rate kontrola jsou dostupné pouze v komerční closed-source verzi.

\subsection{Rsyslog}
Výčet funkcionalit Rsyslogu je ještě obsáhlejší než u Syslog-ng. Technické požadavky se s jeho použitím tedy také dají splnit všechny, kromě vzdálené změny konfigurace. Oproti Syslog-ng je Rsyslog kompletně zdarma a open-source. Navíc není jen logovacím démonem, ale i analyzérem logů. Dokáže logy podle obsahu zprávy měnit, třídit a jinak s nimy nakládat.
Že je Rsyslog vyspělý a kvalitní program dokazuje fakt, že je defaultním logovacím démonem na spoustě linuxových distribucích, jmenovitě například v Ubuntu.
Jeho slabiny shledávám v nedostatečné dokumentaci a ve specifických případech v neefektivním analyzování logů mající za následek (obvzláště na embedded zařízení s pomalým ARM procesorem) rychlostní deficit. Jeho vývoj obstarává z velké většiny pouze jeden člověk, jeho původní tvůrce Rainer Gerhards. A v jednom člověku není snadné dovést tak rozsáhlý projekt k dokonalosti.

\subsection{Porovnání výše zmíněných logovacích utilit}
Pouhým nasazením jakéhokoli známého logovacího démonu není možné splnit všechny vytyčené technické požadavky. V případě ponechání původního BusyBox syslogd démonu by pro splnění technických požadavků bylo nutno doimplementovat tolik funkcionalit, že by to výrazně přesahovalo rozsah bakalářské práce.
Výhodněji se jeví nasadit pokročilý logovací démon jako je Syslog-ng či Rsyslog. Oba totiž poskytují námi požadované funkcionality. Syslog-ng však většinu z nich poskytuje pouze v placené closed-source verzi a proto jsem se rozhodl pro Rsyslog.

\section{Vzdálená konfigurace}
Rsyslog při svém zapnutí čte konfigurační soubor rsyslog.conf, který za jeho běhu není možné měnit. Je proto nutné napsat SHELL-ové API, které umožní na dálku přenastavit tento konfigurační soubor a restartovat Rsyslog. Rsyslog dokáže načíst nový konfigurační soubor zdánlivě i bez restartu a to po obdržení SIGHUP signálu. Avšak ve skutečnosti \cite{RsyslogHUP} k restartu dojde i tak a nelze se proto jeho restartování vyhnout.

Požadavkem zadavatele je umožnit změnu nastavení maximální povolené severity jednotlivých komponent. Tedy nastavit Rsyslog tak, aby v případě rozpoznání zprávy od určité komponenty spolu s nastavenou severitou vyšší, než je povolená, danou zprávu zahodil. Změny tímto skriptem způsobebé musí být zachovány i po restartu STB.

V této kapitole diskutuji možná řešení SHELLL-ového API. Samotná implementace je k nalezení v kapitole Realizace.

\subsection{Logika skriptu}
V úvahu připadaly 2 různé přístupy. Je možné při každém zavolání scriptu generovat celý nový konfigurační soubor a nebo parsovat stávající soubor a jeho část pomocí skriptu měnit.
Výhodou prvního způsobu je, že nehrozí nechtěné přepsání jiných čásí skriptu, než bylo zamýšleno. Nevýhodou je složitější implementace z důvodu nutnosti pří generování nového skriptu zohledňovat předchozí nastavení skritpu. Tedy by bylo nutno z původního skriptu extrahovat nastavení jednotlivých komponent a to zkombinovat s novým nastavením.
Rozhodl jsem se proto pro 2. způsob řešení s tím, že zadavatel bude poučen o nutnosti dodržovat určité zásady při měnění konfiguračního souboru, aby nemohlo dojít k neočekávanému chování.

\subsection{Rozhraní skriptu}
První možností je napsat API ve formě scriptu, který přijímá jednotlivé názvy komponent a jim příslušící maximální povolenou severitu jako parametry.
\begin{scriptsize}
\begin{verbatim}
set_log_verbosity.sh [component] [severity] [component2] [severity] ...
\end{verbatim}
\end{scriptsize}

Jako druhá možnost připadá v úvahu skript, který čte seznam jednotlivých komponent a maximálních povolených severit ze souboru, který má následující formát:

\begin{scriptsize}
\begin{verbatim}
/etc/logging.conf
\end{verbatim}}
\end{scriptsize}

\begin{scriptsize}
\begin{verbatim}
component1  = DEBUG
componentXY = INFO
...
DEFAULT     = INFO
\end{verbatim}
\end{scriptsize}

Se zadavatelem jsme se shodli, že se lépe jeví první způsob pro jeho jednoduší a rycheljší obsluhu a navíc s jeho použitím odpadá starost o další konfigurační soubor.

\section{Postprocessign zpráv}
Všechna níže zmíněná pravidla jsou myšlena jako vzory pro zadavatele, který podle nich v budoucnu vytvoří svá vlastní.
\subsection{Smazání podřetězce z těla syslog zprávy}
Zprávy s nastavenou severitou INFO a komponentou sld\_br je třeba změnit podle následujícího vzoru.

\subsubsection*{Originální zpráva:}
\begin{scriptsize}
\begin{verbatim}
2016-02-18T14:05:24+01:00 cc-b8-f1-00-6f-07 sld_br: id=559 
:[stbhal.cpp:debug:520]: INFO: [94mDEBUG: InformationService:
 Reading 'nangu.video.forcedScart': false[0m
\end{verbatim}}
\end{scriptsize}

\subsubsection*{Výsledná zpráva:}
\begin{scriptsize}
\begin{verbatim}
2016-02-18T14:05:24+01:00 cc-b8-f1-00-6f-07 sld_br: id=559
[94mDEBUG: InformationService: Reading 'nangu.video.forcedScart':
false[0m
\end{verbatim}}
\end{scriptsize}

\subsection{Zahazování zpráv podle typu komponenty}
Je třeba dokázat rozpoznat a zahodit zprávy podle zadané komponenty a obsahující určitý podřetězec.

\subsection{Převod severit}
Aplikace na STB používají pro logování jinou množinu severit, než s jakými pracuje Rsyslog. Zadavatel proto požaduje změnit severity zpráv podle následující tabulky.

\begin{table}[ht]
\centering
	\caption{Převodní tabulka severit}	\begin{tabular}{|l|l|}\hline
		Portal		& Syslog			\tabularnewline \hline \hline
		ERROR		& ERR			\tabularnewline \hline
		WARN		& WARN			\tabularnewline \hline
		INFO		& NOTICE			\tabularnewline \hline
		DEBUG		& INFO			\tabularnewline \hline
		TRACE		& DEBUG			\tabularnewline \hline
	\end{tabular}
\end{table}

\section{Rate-limiting zpráv}
Původní řešení obsahuje rate-limiting implementovaný tím způsobem, že do zdrojového kódu BusyBox syslogd, který je v jednom malém C souboru, byl doimplementován statický buffer s omezenou velikostí pro 128 kB zpráv.

V Rsyslogu se podobného efektu dá dosáhnout prostým nastavením modulu imuxsock, kde parametry RateLimit.Interval a RateLimit.Burst určují maximální povolený počet zpráv za daný počet sekund.
\begin{scriptsize}
\begin{verbatim}
module(load="imuxsock"             #Provides support for local system logging.
	SysSock.RateLimit.Interval="2" #Specifies the rate-limiting interval in seconds.
	SysSock.RateLimit.Burst="500"  #Specifies the rate-limiting burst in number of messages.
)
\end{verbatim}
\end{scriptsize}
Původní řešení trápí neduh, kdy k vyprázdnění bufferu dochází až s nově příchozí zprávou, což má za následek, že v případě zaplněného bufferu a následující delší odmlky nově příchozích zpráv může dojit k velkému zpoždení odeslání zpráv v ten moment uložených v bufferu. Tento problém se sofistikovanějišího Rsyslogu netýká.

V sekci Testování se zabývám hledáním ideálního nastavení těchto parametrů.

\chapter{Realizace}

\section{Rsyslog}

\subsection{Build}
Jelikož Rsyslog není součástí SDK, bylo ho nutné a všechny knihovny na kterých závisí (zlib, libestr, libee, liblogging, libfastjson) zkompilovat a posléze nainstalovat na STB.




\subsection{Konfigurace}

TODO jednotlivy configurace pro pravidla, dodat ukázky configů..
krome popsani rsyslog.conf i logrotate etc all scripty
nebo mozna do jine podsekce toto

\subsection{spouštění}
protože se musí upravit rsys.conf dke se nastaví MAC addr která následně bude v hlavičce každe zprávy

\subsection{Programování vlastích modulů}

Rsyslog nepodporuje TODO..
http://www.rsyslog.com/doc/v8-stable/configuration/modules/index.html

\subsubsection{Modul mmstrdel}

%TODO language zmenit na Rainerscript a ten si sam nadefinovat.
\begin{lstlisting}
module(load="mmdelstr") 
action(type="mmdelstr" stringtobedeleted="Some string")
\end{lstlisting}


\subsubsection{Modul mmsevrewrite}

\begin{lstlisting}
module(load="mmsevrewrite")
action(type="mmsevrewrite" severity="debug")
\end{lstlisting}


\section{Shell API}
Na STB je přítomna pouze minimalistická BusyBox implementace SHELLu nesoucí název ASH, která neposkytuje tak elegantní syntaxi a neposkytuje tolik rozšířených funkcionalit jako moderní SHELL-ové jazyky typu BASH. I přesto se s pomocí ASHe a základních UNIXových programů jako například GREP povedlo API naprogramovat.
Skript na vstupu očekává sudý počet parametrů, kde každý sudý parametr je název komponenty a liché parametry slouží pro definování severit.
Skript vyhledá v konfiguračním souboru rsyslog.conf řádek s danou komponentou a přenastaví maximální povolenou severitu. Skript kontrolojue správnost vstupních parametrů pro zabránení neočekávaného chování programu.
%\begin{lstlisting}[language=Bash]
%TODO code
%\end{lstlisting}

\section{dmd}

\chapter{Testování}

\begin{conclusion}

\end{conclusion}

\bibliographystyle{csn690}
\bibliography{mybibliographyfile}

\appendix

\chapter{Seznam použitých zkratek}
\begin{description}
	\item[API] Application Programming Interface
	\item[ASH] Almquist Shell
	\item[CPU] Central Processing Unit
	\item[dmd] Download manager daemon
	\item[GPU] Graphics processing unit
	\item[OS] Operační systém
	\item[RAM] Random Access memory
	\item[RFC] Request for Comments
	\item[SDK] Software Development Kit
	\item[STB] Set-top box
	\item[SIGHUP] Signal Hang Up
\end{description}

\chapter{Obsah přiloženého CD}

\begin{figure}
	\dirtree{%
		.1 readme.txt\DTcomment{stručný popis obsahu CD}.
		.1 exe\DTcomment{adresář se spustitelnou formou implementace}.
		.1 src.
		.2 impl\DTcomment{zdrojové kódy implementace}.
		.2 thesis\DTcomment{zdrojová forma práce ve formátu \LaTeX{}}.
		.1 text\DTcomment{text práce}.
		.2 thesis.pdf\DTcomment{text práce ve formátu PDF}.
		.2 BP\_Vavricka\_David\_2016.pdf\DTcomment{text práce ve formátu PDF}.
	}
\end{figure}

\end{document}
